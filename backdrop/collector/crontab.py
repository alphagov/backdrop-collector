import argparse
import os
import sys


class ParseError(StandardError):
    pass


def generate_crontab(current_crontab, path_to_jobs, path_to_app):
    """Returns a crontab with jobs from job path

    It replaces jobs previously generated by this function
    It preserves jobs not generated by this function
    """
    job_template = '{schedule} {python} -m backdrop.collector.crontab ' \
                   '-q {app_path}/{query} -c {app_path}/{config} ' \
                   '# {app_name}'

    app_name = os.path.basename(path_to_app)
    app_comment = "# %s" % app_name
    crontab = [
        line.strip() for line in current_crontab if app_comment not in line
    ]
    with open(path_to_jobs) as jobs:
        try:
            for job in jobs:
                schedule, query, config = job.strip().split(",")

                cronjob = job_template.format(
                    schedule=schedule,
                    python=sys.executable,
                    app_path=path_to_app,
                    query=query,
                    config=config,
                    app_name=app_name
                )

                crontab.append(cronjob)
        except ValueError as e:
            raise ParseError(str(e))

    return crontab


if __name__ == '__main__':
    current_crontab = sys.stdin.readlines()
    try:
        parser = argparse.ArgumentParser()
        parser.add_argument('path_to_app',
                            help='Path to where the application')
        parser.add_argument('path_to_jobs',
                            help='Path to the file where job templates are')

        args = parser.parse_args()

        crontab = generate_crontab(current_crontab,
                                   args.path_to_jobs,
                                   args.path_to_app)
        sys.stdout.write("\n".join(crontab) + "\n")
        sys.exit(0)
    except StandardError as e:
        sys.stderr.write(str(e))
        sys.stdout.write("\n".join(current_crontab))
        sys.exit(1)
